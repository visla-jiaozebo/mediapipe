<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>美颜算法对比 - CPU vs GPU</title>
    
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="stylesheet" href="styles.css">
    
    <style>
        .comparison-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }
        
        .comparison-box {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .comparison-box.cpu {
            border-color: #ff6b6b;
        }
        
        .comparison-box.gpu {
            border-color: #667eea;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8ecff 100%);
        }
        
        .comparison-box h3 {
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .cpu-badge {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .gpu-badge {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            animation: glow 2s infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px rgba(102, 126, 234, 0.5); }
            50% { box-shadow: 0 0 20px rgba(102, 126, 234, 0.8); }
        }
        
        .performance-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .performance-table th,
        .performance-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        .performance-table th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        
        .performance-table .gpu-row {
            background-color: #e8f2ff;
        }
        
        .performance-table .cpu-row {
            background-color: #fff5f5;
        }
        
        .demo-links {
            display: flex;
            gap: 20px;
            margin: 30px 0;
            justify-content: center;
        }
        
        .demo-link {
            display: inline-block;
            padding: 15px 30px;
            text-decoration: none;
            border-radius: 10px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .demo-link.cpu {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            color: white;
        }
        
        .demo-link.gpu {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        .demo-link:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        
        .algorithm-explanation {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
        }
        
        .code-snippet {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        .highlight {
            color: #569cd6;
        }
        
        .comment {
            color: #6a9955;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>🔬 美颜算法技术对比</h1>
            <p>CPU OpenCV.js vs GPU WebGL Shader 实现对比分析</p>
        </header>

        <div class="main-content">
            <!-- 在线演示链接 -->
            <div class="demo-links">
                <a href="index.html" class="demo-link cpu">
                    🖥️ CPU版本演示<br>
                    <small>OpenCV.js + MediaPipe</small>
                </a>
                <a href="webgl-beauty.html" class="demo-link gpu">
                    🚀 GPU版本演示<br>
                    <small>WebGL Shader + MediaPipe</small>
                </a>
            </div>

            <!-- 性能对比 -->
            <div class="algorithm-explanation">
                <h3>⚡ 性能对比分析</h3>
                <table class="performance-table">
                    <thead>
                        <tr>
                            <th>对比项目</th>
                            <th>CPU版本 (OpenCV.js)</th>
                            <th>GPU版本 (WebGL Shader)</th>
                            <th>性能提升</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="cpu-row">
                            <td><strong>处理时间</strong></td>
                            <td>500-2000ms</td>
                            <td>10-50ms</td>
                            <td><span style="color: #28a745;">10-40倍</span></td>
                        </tr>
                        <tr class="gpu-row">
                            <td><strong>内存使用</strong></td>
                            <td>高（多次矩阵复制）</td>
                            <td>低（GPU直接处理）</td>
                            <td><span style="color: #28a745;">3-5倍降低</span></td>
                        </tr>
                        <tr class="cpu-row">
                            <td><strong>变形质量</strong></td>
                            <td>中等（线性插值）</td>
                            <td>高（亚像素精度）</td>
                            <td><span style="color: #28a745;">质量提升</span></td>
                        </tr>
                        <tr class="gpu-row">
                            <td><strong>实时性</strong></td>
                            <td>不支持</td>
                            <td>支持60FPS</td>
                            <td><span style="color: #28a745;">实时处理</span></td>
                        </tr>
                        <tr class="cpu-row">
                            <td><strong>兼容性</strong></td>
                            <td>较好</td>
                            <td>需WebGL支持</td>
                            <td><span style="color: #ffc107;">略低</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- 算法实现对比 -->
            <div class="comparison-section">
                <div class="comparison-box cpu">
                    <h3>🖥️ CPU版本实现 <span class="cpu-badge">OpenCV.js</span></h3>
                    
                    <h4>特点：</h4>
                    <ul>
                        <li>基于OpenCV.js的图像处理</li>
                        <li>JavaScript单线程执行</li>
                        <li>内存频繁分配释放</li>
                        <li>矩阵运算较慢</li>
                    </ul>
                    
                    <h4>核心算法：</h4>
                    <div class="code-snippet">
<span class="comment">// CPU版本 - 径向变形</span>
<span class="highlight">for</span> (let y = 0; y &lt; height; y++) {
    <span class="highlight">for</span> (let x = 0; x &lt; width; x++) {
        <span class="comment">// 计算距离</span>
        const distance = <span class="highlight">Math.sqrt</span>(dx*dx + dy*dy);
        
        <span class="comment">// 应用变形</span>
        <span class="highlight">if</span> (distance &lt; radius) {
            const weight = 1.0 - (1.0 - weight*weight) * delta;
            newX = center.x + dx * weight;
            newY = center.y + dy * weight;
        }
        
        <span class="comment">// 设置映射矩阵</span>
        mapX.<span class="highlight">floatPtr</span>(y, x)[0] = newX;
        mapY.<span class="highlight">floatPtr</span>(y, x)[0] = newY;
    }
}
<span class="comment">// 应用重映射</span>
cv.<span class="highlight">remap</span>(src, dst, mapX, mapY, cv.INTER_CUBIC);
                    </div>
                    
                    <h4>优势：</h4>
                    <ul>
                        <li>✅ 实现简单，易于调试</li>
                        <li>✅ 兼容性好</li>
                        <li>✅ 功能丰富（OpenCV库）</li>
                    </ul>
                    
                    <h4>劣势：</h4>
                    <ul>
                        <li>❌ 处理速度慢</li>
                        <li>❌ 内存占用高</li>
                        <li>❌ 不支持实时处理</li>
                        <li>❌ 变形效果一般</li>
                    </ul>
                </div>

                <div class="comparison-box gpu">
                    <h3>🚀 GPU版本实现 <span class="gpu-badge">WebGL Shader</span></h3>
                    
                    <h4>特点：</h4>
                    <ul>
                        <li>基于WebGL着色器程序</li>
                        <li>GPU并行计算</li>
                        <li>纹理直接处理</li>
                        <li>硬件加速渲染</li>
                    </ul>
                    
                    <h4>核心算法：</h4>
                    <div class="code-snippet">
<span class="comment">// GPU版本 - 片段着色器</span>
<span class="highlight">vec2</span> enlargeEye(<span class="highlight">vec2</span> texCoord, <span class="highlight">vec2</span> center, 
               <span class="highlight">float</span> radius, <span class="highlight">float</span> delta) {
    
    <span class="comment">// 计算归一化距离</span>
    <span class="highlight">float</span> weight = <span class="highlight">distance</span>(
        <span class="highlight">vec2</span>(texCoord.x, texCoord.y / aspectRatio), 
        <span class="highlight">vec2</span>(center.x, center.y / aspectRatio)
    ) / radius;
    
    <span class="comment">// 平滑衰减函数</span>
    weight = 1.0 - (1.0 - weight * weight) * delta;
    weight = <span class="highlight">clamp</span>(weight, 0.0, 1.0);
    
    <span class="comment">// 应用变形</span>
    texCoord = center + (texCoord - center) * weight;
    <span class="highlight">return</span> texCoord;
}

<span class="comment">// 主函数</span>
<span class="highlight">void</span> main() {
    <span class="highlight">vec2</span> texCoord = v_texCoord;
    texCoord = <span class="highlight">bigEye</span>(texCoord);
    texCoord = <span class="highlight">thinFace</span>(texCoord);
    
    gl_FragColor = <span class="highlight">texture2D</span>(u_texture, texCoord);
}
                    </div>
                    
                    <h4>优势：</h4>
                    <ul>
                        <li>✅ 处理速度极快（GPU并行）</li>
                        <li>✅ 支持实时处理</li>
                        <li>✅ 内存使用低</li>
                        <li>✅ 变形效果自然</li>
                        <li>✅ 亚像素精度</li>
                    </ul>
                    
                    <h4>劣势：</h4>
                    <ul>
                        <li>❌ 需要WebGL支持</li>
                        <li>❌ 着色器编程复杂</li>
                        <li>❌ 调试困难</li>
                    </ul>
                </div>
            </div>

            <!-- 技术架构对比 -->
            <div class="algorithm-explanation">
                <h3>🏗️ 技术架构对比</h3>
                
                <div class="comparison-section">
                    <div class="comparison-box cpu">
                        <h4>CPU版本架构</h4>
                        <div class="code-snippet">
<span class="comment">// 处理流程</span>
MediaPipe <span class="highlight">→</span> 获取关键点
    ↓
OpenCV.js <span class="highlight">→</span> 创建映射矩阵
    ↓
CPU计算 <span class="highlight">→</span> 逐像素变形
    ↓
内存拷贝 <span class="highlight">→</span> 显示结果
                        </div>
                        <p><strong>特点：</strong>串行处理，内存开销大</p>
                    </div>

                    <div class="comparison-box gpu">
                        <h4>GPU版本架构</h4>
                        <div class="code-snippet">
<span class="comment">// 处理流程</span>
MediaPipe <span class="highlight">→</span> 获取关键点
    ↓
WebGL <span class="highlight">→</span> 传递到GPU
    ↓
Shader并行 <span class="highlight">→</span> 所有像素同时处理
    ↓
GPU渲染 <span class="highlight">→</span> 直接输出结果
                        </div>
                        <p><strong>特点：</strong>并行处理，零拷贝，硬件加速</p>
                    </div>
                </div>
            </div>

            <!-- 算法细节对比 -->
            <div class="algorithm-explanation">
                <h3>🔍 算法实现细节</h3>
                
                <h4>1. 大眼算法对比</h4>
                <p><strong>CPU版本：</strong>使用OpenCV的remap函数，需要创建映射矩阵，然后逐像素重映射</p>
                <p><strong>GPU版本：</strong>直接在片段着色器中计算纹理坐标变换，GPU并行处理所有像素</p>
                
                <h4>2. 瘦脸算法对比</h4>
                <p><strong>CPU版本：</strong>基于脸部轮廓点的径向收缩，使用二次函数衰减</p>
                <p><strong>GPU版本：</strong>参考GPUPixel的curveWarp算法，多点曲线变形，效果更自然</p>
                
                <h4>3. 磨皮算法对比</h4>
                <p><strong>CPU版本：</strong>高斯模糊 + 蒙版混合，需要多次内存分配</p>
                <p><strong>GPU版本：</strong>双边滤波着色器，保边缘去噪点，一次处理完成</p>
            </div>

            <!-- 总结 -->
            <div class="algorithm-explanation">
                <h3>📊 总结建议</h3>
                <div class="comparison-section">
                    <div class="comparison-box cpu">
                        <h4>适用场景 - CPU版本</h4>
                        <ul>
                            <li>🎯 学习和理解算法原理</li>
                            <li>🎯 对兼容性要求很高的场景</li>
                            <li>🎯 不需要实时处理的应用</li>
                            <li>🎯 快速原型开发</li>
                        </ul>
                    </div>

                    <div class="comparison-box gpu">
                        <h4>适用场景 - GPU版本</h4>
                        <ul>
                            <li>🚀 生产环境的美颜应用</li>
                            <li>🚀 需要实时处理的场景</li>
                            <li>🚀 对性能要求高的应用</li>
                            <li>🚀 移动端美颜相机</li>
                            <li>🚀 直播美颜功能</li>
                        </ul>
                    </div>
                </div>
                
                <p style="text-align: center; margin-top: 30px; font-size: 16px; color: #667eea;">
                    <strong>💡 建议：实际项目中推荐使用GPU版本，性能和效果都有显著提升！</strong>
                </p>
            </div>
        </div>
    </div>
</body>
</html>
