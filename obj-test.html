<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canonical Face Model OBJ è§£ææµ‹è¯•</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .results {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        .vertex-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        
        .vertex-table th, .vertex-table td {
            border: 1px solid #ddd;
            padding: 5px;
            text-align: center;
        }
        
        .vertex-table th {
            background: #f8f9fa;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ—¿ Canonical Face Model OBJ è§£ææµ‹è¯•</h1>
        
        <div class="test-section">
            <h3>è§£ææ§åˆ¶</h3>
            <button onclick="loadAndParseOBJ()">è§£æ canonical_face_model.obj</button>
            <button onclick="showLipVertices()">æ˜¾ç¤ºå”‡éƒ¨é¡¶ç‚¹</button>
            <button onclick="showEyeVertices()">æ˜¾ç¤ºçœ¼éƒ¨é¡¶ç‚¹</button>
            <button onclick="showAllVertices()">æ˜¾ç¤ºæ‰€æœ‰é¡¶ç‚¹ï¼ˆå‰20ä¸ªï¼‰</button>
            <button onclick="exportToJSON()">å¯¼å‡ºJSONæ•°æ®</button>
        </div>
        
        <div class="test-section">
            <h3>è§£æç»“æœ</h3>
            <div id="parseResults" class="results">ç­‰å¾…è§£æ...</div>
        </div>
        
        <div class="test-section">
            <h3>é¡¶ç‚¹æ•°æ®è¡¨æ ¼</h3>
            <table id="vertexTable" class="vertex-table" style="display: none;">
                <thead>
                    <tr>
                        <th>ç´¢å¼•</th>
                        <th>åŸå§‹X</th>
                        <th>åŸå§‹Y</th>
                        <th>åŸå§‹Z</th>
                        <th>æ ‡å‡†åŒ–X</th>
                        <th>æ ‡å‡†åŒ–Y</th>
                        <th>æ ‡å‡†åŒ–Z</th>
                    </tr>
                </thead>
                <tbody id="vertexTableBody">
                </tbody>
            </table>
        </div>
        
        <div class="test-section">
            <h3>3Dåæ ‡å¯è§†åŒ–</h3>
            <canvas id="visualCanvas" width="400" height="300" style="border: 1px solid #ddd;"></canvas>
            <p>ç®€å•çš„2DæŠ•å½±æ˜¾ç¤ºé¡¶ç‚¹åˆ†å¸ƒ</p>
        </div>
    </div>

    <!-- å¯¼å…¥æˆ‘ä»¬çš„OBJè§£æå™¨ -->
    <script type="module">
        // ç›´æ¥åµŒå…¥OBJè§£æé€»è¾‘ï¼Œé¿å…æ¨¡å—å¯¼å…¥é—®é¢˜
        class OBJParser {
            static async parseOBJFile(filePath) {
                try {
                    const response = await fetch(filePath);
                    const objContent = await response.text();
                    return this.parseOBJContent(objContent);
                } catch (error) {
                    console.error('Failed to load OBJ file:', error);
                    throw error;
                }
            }
            
            static parseOBJContent(objContent) {
                const lines = objContent.split('\n');
                const rawVertices = [];
                
                // è§£æé¡¶ç‚¹
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    
                    if (trimmedLine.startsWith('v ')) {
                        const parts = trimmedLine.split(/\s+/);
                        if (parts.length >= 4) {
                            const x = parseFloat(parts[1]);
                            const y = parseFloat(parts[2]);
                            const z = parseFloat(parts[3]);
                            
                            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                                rawVertices.push({ x, y, z });
                            }
                        }
                    }
                }
                
                if (rawVertices.length === 0) {
                    throw new Error('No vertices found in OBJ file');
                }
                
                // è®¡ç®—è¾¹ç•Œæ¡†
                const bounds = this.calculateBounds(rawVertices);
                
                // æ ‡å‡†åŒ–é¡¶ç‚¹åˆ°[0,1]èŒƒå›´
                const normalizedVertices = this.normalizeVertices(rawVertices, bounds);
                
                // è½¬æ¢ä¸ºFloat32Array
                const originalVerticesArray = new Float32Array(rawVertices.length * 3);
                const normalizedVerticesArray = new Float32Array(rawVertices.length * 3);
                
                for (let i = 0; i < rawVertices.length; i++) {
                    originalVerticesArray[i * 3] = rawVertices[i].x;
                    originalVerticesArray[i * 3 + 1] = rawVertices[i].y;
                    originalVerticesArray[i * 3 + 2] = rawVertices[i].z;
                    
                    normalizedVerticesArray[i * 3] = normalizedVertices[i].x;
                    normalizedVerticesArray[i * 3 + 1] = normalizedVertices[i].y;
                    normalizedVerticesArray[i * 3 + 2] = normalizedVertices[i].z;
                }
                
                return {
                    vertices: normalizedVerticesArray,
                    originalVertices: originalVerticesArray,
                    bounds: bounds,
                    vertexCount: rawVertices.length,
                    rawVertices: rawVertices,
                    normalizedVertices: normalizedVertices
                };
            }
            
            static calculateBounds(vertices) {
                const first = vertices[0];
                const bounds = {
                    min: { x: first.x, y: first.y, z: first.z },
                    max: { x: first.x, y: first.y, z: first.z }
                };
                
                for (const vertex of vertices) {
                    bounds.min.x = Math.min(bounds.min.x, vertex.x);
                    bounds.min.y = Math.min(bounds.min.y, vertex.y);
                    bounds.min.z = Math.min(bounds.min.z, vertex.z);
                    
                    bounds.max.x = Math.max(bounds.max.x, vertex.x);
                    bounds.max.y = Math.max(bounds.max.y, vertex.y);
                    bounds.max.z = Math.max(bounds.max.z, vertex.z);
                }
                
                return bounds;
            }
            
            static normalizeVertices(vertices, bounds) {
                const sizeX = bounds.max.x - bounds.min.x;
                const sizeY = bounds.max.y - bounds.min.y;
                const sizeZ = bounds.max.z - bounds.min.z;
                
                const safeSize = {
                    x: sizeX || 1,
                    y: sizeY || 1,
                    z: sizeZ || 1
                };
                
                return vertices.map(vertex => ({
                    x: (vertex.x - bounds.min.x) / safeSize.x,
                    y: (vertex.y - bounds.min.y) / safeSize.y,
                    z: (vertex.z - bounds.min.z) / safeSize.z
                }));
            }
        }
        
        // å…¨å±€å˜é‡å­˜å‚¨è§£æç»“æœ
        let parsedOBJData = null;
        
        // è§£æå‡½æ•°
        window.loadAndParseOBJ = async function() {
            const resultsDiv = document.getElementById('parseResults');
            resultsDiv.textContent = 'æ­£åœ¨è§£æ...';
            
            try {
                parsedOBJData = await OBJParser.parseOBJFile('gl/canonical_face_model.obj');
                
                let output = '=== OBJ è§£ææˆåŠŸ ===\n';
                output += `é¡¶ç‚¹æ•°é‡: ${parsedOBJData.vertexCount}\n`;
                output += `åŸå§‹è¾¹ç•Œæ¡†:\n`;
                output += `  X: ${parsedOBJData.bounds.min.x.toFixed(3)} ~ ${parsedOBJData.bounds.max.x.toFixed(3)}\n`;
                output += `  Y: ${parsedOBJData.bounds.min.y.toFixed(3)} ~ ${parsedOBJData.bounds.max.y.toFixed(3)}\n`;
                output += `  Z: ${parsedOBJData.bounds.min.z.toFixed(3)} ~ ${parsedOBJData.bounds.max.z.toFixed(3)}\n\n`;
                
                output += 'å‰10ä¸ªé¡¶ç‚¹å¯¹æ¯”:\n';
                for (let i = 0; i < Math.min(10, parsedOBJData.vertexCount); i++) {
                    const orig = parsedOBJData.rawVertices[i];
                    const norm = parsedOBJData.normalizedVertices[i];
                    output += `${i}: (${orig.x.toFixed(3)}, ${orig.y.toFixed(3)}, ${orig.z.toFixed(3)}) â†’ (${norm.x.toFixed(3)}, ${norm.y.toFixed(3)}, ${norm.z.toFixed(3)})\n`;
                }
                
                resultsDiv.textContent = output;
                visualizeVertices();
                
            } catch (error) {
                resultsDiv.textContent = `è§£æå¤±è´¥: ${error.message}`;
            }
        };
        
        window.showLipVertices = function() {
            if (!parsedOBJData) {
                alert('è¯·å…ˆè§£æOBJæ–‡ä»¶');
                return;
            }
            
            // MediaPipeå”‡éƒ¨å…³é”®ç‚¹ç´¢å¼•
            const lipIndices = [61, 84, 17, 314, 405, 320, 307, 375, 321, 308, 324, 291];
            showVerticesTable(lipIndices, 'å”‡éƒ¨');
        };
        
        window.showEyeVertices = function() {
            if (!parsedOBJData) {
                alert('è¯·å…ˆè§£æOBJæ–‡ä»¶');
                return;
            }
            
            // çœ¼éƒ¨å…³é”®ç‚¹ç´¢å¼•
            const eyeIndices = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160];
            showVerticesTable(eyeIndices, 'çœ¼éƒ¨');
        };
        
        window.showAllVertices = function() {
            if (!parsedOBJData) {
                alert('è¯·å…ˆè§£æOBJæ–‡ä»¶');
                return;
            }
            
            const indices = Array.from({length: 20}, (_, i) => i);
            showVerticesTable(indices, 'æ‰€æœ‰é¡¶ç‚¹ï¼ˆå‰20ä¸ªï¼‰');
        };
        
        function showVerticesTable(indices, title) {
            const table = document.getElementById('vertexTable');
            const tbody = document.getElementById('vertexTableBody');
            
            tbody.innerHTML = '';
            
            for (const index of indices) {
                if (index < parsedOBJData.vertexCount) {
                    const orig = parsedOBJData.rawVertices[index];
                    const norm = parsedOBJData.normalizedVertices[index];
                    
                    const row = tbody.insertRow();
                    row.insertCell(0).textContent = index;
                    row.insertCell(1).textContent = orig.x.toFixed(3);
                    row.insertCell(2).textContent = orig.y.toFixed(3);
                    row.insertCell(3).textContent = orig.z.toFixed(3);
                    row.insertCell(4).textContent = norm.x.toFixed(3);
                    row.insertCell(5).textContent = norm.y.toFixed(3);
                    row.insertCell(6).textContent = norm.z.toFixed(3);
                }
            }
            
            table.style.display = 'table';
            table.querySelector('caption')?.remove();
            const caption = table.createCaption();
            caption.textContent = title;
        }
        
        function visualizeVertices() {
            const canvas = document.getElementById('visualCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!parsedOBJData) return;
            
            // ç®€å•çš„2DæŠ•å½±ï¼šä½¿ç”¨X-Yåæ ‡ï¼Œå¿½ç•¥Z
            ctx.fillStyle = '#007bff';
            
            for (let i = 0; i < Math.min(100, parsedOBJData.vertexCount); i++) {
                const norm = parsedOBJData.normalizedVertices[i];
                const x = norm.x * canvas.width;
                const y = norm.y * canvas.height;
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        window.exportToJSON = function() {
            if (!parsedOBJData) {
                alert('è¯·å…ˆè§£æOBJæ–‡ä»¶');
                return;
            }
            
            const exportData = {
                vertexCount: parsedOBJData.vertexCount,
                bounds: parsedOBJData.bounds,
                normalizedVertices: Array.from(parsedOBJData.vertices),
                originalVertices: Array.from(parsedOBJData.originalVertices)
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = 'canonical_face_model_parsed.json';
            link.click();
        };
        
        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨è§£æ
        document.addEventListener('DOMContentLoaded', function() {
            console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œå‡†å¤‡è§£æOBJæ–‡ä»¶...');
        });
        
    </script>
</body>
</html>
