<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shaderæµ‹è¯•</title>
</head>
<body>
    <h1>ShaderåŠ è½½æµ‹è¯•</h1>
    <div id="result"></div>
    <canvas id="canvas" width="512" height="512" style="border: 1px solid black;"></canvas>

    <script>
        async function testShaderLoading() {
            const resultDiv = document.getElementById('result');
            
            try {
                // æµ‹è¯•shaderæ–‡ä»¶åŠ è½½
                console.log('å¼€å§‹æµ‹è¯•shaderæ–‡ä»¶åŠ è½½...');
                resultDiv.innerHTML += '<p>ğŸ”„ æ­£åœ¨åŠ è½½vertex shader...</p>';
                
                const vertResponse = await fetch('gl/facebeauty.vert');
                if (!vertResponse.ok) {
                    throw new Error('Vertex shaderåŠ è½½å¤±è´¥');
                }
                const vertexShaderSource = await vertResponse.text();
                console.log('Vertex shaderåŠ è½½æˆåŠŸ:', vertexShaderSource.length, 'ä¸ªå­—ç¬¦');
                resultDiv.innerHTML += '<p>âœ… Vertex shaderåŠ è½½æˆåŠŸ</p>';
                
                resultDiv.innerHTML += '<p>ğŸ”„ æ­£åœ¨åŠ è½½fragment shader...</p>';
                const fragResponse = await fetch('gl/facebeauty.frag');
                if (!fragResponse.ok) {
                    throw new Error('Fragment shaderåŠ è½½å¤±è´¥');
                }
                const fragmentShaderSource = await fragResponse.text();
                console.log('Fragment shaderåŠ è½½æˆåŠŸ:', fragmentShaderSource.length, 'ä¸ªå­—ç¬¦');
                resultDiv.innerHTML += '<p>âœ… Fragment shaderåŠ è½½æˆåŠŸ</p>';
                
                // æµ‹è¯•WebGLç¼–è¯‘
                resultDiv.innerHTML += '<p>ğŸ”„ æ­£åœ¨æµ‹è¯•WebGLç¼–è¯‘...</p>';
                const canvas = document.getElementById('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                if (!gl) {
                    throw new Error('WebGLä¸æ”¯æŒ');
                }
                
                // ç¼–è¯‘vertex shader
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, vertexShaderSource);
                gl.compileShader(vertexShader);
                
                if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                    const error = gl.getShaderInfoLog(vertexShader);
                    throw new Error('Vertex shaderç¼–è¯‘å¤±è´¥: ' + error);
                }
                console.log('Vertex shaderç¼–è¯‘æˆåŠŸ');
                resultDiv.innerHTML += '<p>âœ… Vertex shaderç¼–è¯‘æˆåŠŸ</p>';
                
                // ç¼–è¯‘fragment shader
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, fragmentShaderSource);
                gl.compileShader(fragmentShader);
                
                if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                    const error = gl.getShaderInfoLog(fragmentShader);
                    throw new Error('Fragment shaderç¼–è¯‘å¤±è´¥: ' + error);
                }
                console.log('Fragment shaderç¼–è¯‘æˆåŠŸ');
                resultDiv.innerHTML += '<p>âœ… Fragment shaderç¼–è¯‘æˆåŠŸ</p>';
                
                // é“¾æ¥ç¨‹åº
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    const error = gl.getProgramInfoLog(program);
                    throw new Error('Shaderç¨‹åºé“¾æ¥å¤±è´¥: ' + error);
                }
                console.log('Shaderç¨‹åºé“¾æ¥æˆåŠŸ');
                resultDiv.innerHTML += '<p>âœ… Shaderç¨‹åºé“¾æ¥æˆåŠŸ</p>';
                
                // æ£€æŸ¥uniformä½ç½®
                const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
                console.log('ç¨‹åºåŒ…å«', numUniforms, 'ä¸ªuniform');
                resultDiv.innerHTML += `<p>ğŸ“Š ç¨‹åºåŒ…å« ${numUniforms} ä¸ªuniform</p>`;
                
                for (let i = 0; i < numUniforms; i++) {
                    const uniformInfo = gl.getActiveUniform(program, i);
                    const location = gl.getUniformLocation(program, uniformInfo.name);
                    console.log('- Uniform:', uniformInfo.name, 'ç±»å‹:', uniformInfo.type, 'ä½ç½®:', location);
                    resultDiv.innerHTML += `<p style="margin-left: 20px;">â€¢ ${uniformInfo.name} (ç±»å‹: ${uniformInfo.type})</p>`;
                }
                
                resultDiv.innerHTML += '<p style="color: green; font-weight: bold;">ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼</p>';
                
            } catch (error) {
                console.error('æµ‹è¯•å¤±è´¥:', error);
                resultDiv.innerHTML += `<p style="color: red;">âŒ æµ‹è¯•å¤±è´¥: ${error.message}</p>`;
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåå¼€å§‹æµ‹è¯•
        document.addEventListener('DOMContentLoaded', testShaderLoading);
    </script>
</body>
</html>
